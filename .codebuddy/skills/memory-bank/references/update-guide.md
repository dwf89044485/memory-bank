# 更新指南

<!-- Memory-Bank by JosephDeng | update-guide -->

当用户说「更新记忆」「update memory」或 AI 检测到更新信号时，按此指南执行。

## 核心理念

> 记忆库不是「文档」，是「活的上下文」。
> 它应该随着项目自然生长，而不是要求用户刻意维护。

**初始化**：低摩擦，快速建立粗粒度理解  
**持续更新**：随着协作深入，逐渐丰富和修正

## 1. 更新原则

### 1.1 增量优先

优先添加新信息，而不是替换旧信息。

```
除非用户明确说"之前的理解是错的"，否则保留历史记录。
用追加而非覆盖的方式更新。
```

### 1.2 具体化

用具体信息替换模糊描述：

| 模糊 | 具体 |
|------|------|
| 提升用户体验 | 减少表单填写步骤从 5 步到 2 步 |
| 优化性能 | 搜索响应时间 < 200ms |
| 面向企业用户 | 面向 500-2000 人规模的中型企业 |
| [待补充] | 实际收集到的信息 |

### 1.3 决策沉淀

当对话中出现以下信号时，记录到 decisions.mdc：

- "我们决定..."
- "最终选择..."
- "不做 X，因为..."
- "之前的方案改成..."
- "放弃了 X，选择 Y"

### 1.4 保持简洁

- brief.mdc 保持简洁，避免冗余描述
- 决策过多时（3+ 条）拆分到 decisions.mdc
- 设计资产信息拆分到 assets.mdc
- 删除过时信息，保持记忆库的时效性

**字数参考**：
- brief.mdc：1000-2000 字（中文字数），重点是「必要」而非「简短」
- decisions.mdc：按需扩展，每条决策 100-200 字
- assets.mdc：按需扩展

## 2. 更新信号检测

### 2.1 主动触发

用户明确要求更新：

- "更新记忆"
- "update memory"
- "记住这个决策"
- "把这个加到记忆库"

### 2.2 被动检测（AI 主动提醒）

| 信号 | 动作 |
|------|------|
| 对话内容与 brief 记录矛盾 | 询问：「我注意到 X 和之前记录的 Y 不一致，需要更新吗？」 |
| 出现重要决策 | 询问：「这个决策要记录到记忆库吗？」 |
| 补充了 [待补充] 的信息 | 自动更新，简单告知用户 |
| 项目阶段发生变化 | 提醒：「项目似乎进入了新阶段，要更新当前状态吗？」 |
| 工作焦点明显转移 | 询问：「工作焦点是否已经从 X 转移到 Y？」 |

### 2.3 不要更新的情况

- 临时性的讨论，没有形成结论
- 用户明确说"这只是想法，还没确定"
- 纯技术实现细节（除非影响产品决策）
- 一次性的操作指令

## 3. 精细化路径

记忆库应该从粗粒度逐渐精细化：

```
初始化（粗粒度）              持续更新（精细化）
────────────────────────────────────────────────────
产品名：企业知识库       →    产品名：企业知识库
                              定位：面向中大型企业的知识管理平台
                              
竞品：Notion、Confluence →    竞品：Notion（内容组织）、Confluence（企业协作）
                              差异化：更强的权限管理 + 本地化部署
                              
焦点：优化搜索体验       →    焦点：优化搜索体验
                              具体目标：搜索响应时间 < 200ms，召回率 > 90%
                              
[待补充]                 →    用户角色：
                              - 知识贡献者（写文档）
                              - 知识消费者（查文档）
                              - 管理员（权限管理）
```

### 精细化维度

| 维度 | 初始化 | 精细化方向 |
|------|--------|-----------|
| **用户** | [待补充] | 角色、痛点、使用场景、优先级 |
| **竞品** | 名称 | 差异化定位、优劣势对比、学习点 |
| **焦点** | 一句话 | 具体目标、成功指标、时间节点 |
| **决策** | 初始化记录 | 每次重要决策的背景、选项、理由 |
| **约束** | [待补充] | 技术限制、资源限制、时间限制 |

## 4. 更新流程

### 重要说明

| 场景 | 流程 | 原因 |
|------|------|------|
| **初始化** | 直接生成 `.mdc` 文件，立即生效 | 确保鲁棒性，避免用户忘记确认导致不生效 |
| **更新** | 直接修改 `.mdc`，告知变更内容 | 基于已有内容增量修改 |

**核心原则**：所有操作都直接作用于 `.mdc` 文件，确保记忆库始终处于生效状态。

### Step 1: 读取现有记忆

1. 读取 `.codebuddy/rules/brief.mdc`
2. 读取 `.codebuddy/rules/decisions.mdc`（如存在）

### Step 2: 分析更新内容

1. 对比对话中的新信息与现有记录
2. 识别需要更新的字段
3. 判断是「补充」还是「修正」还是「新增」

### Step 3: 直接更新 .mdc 文件

<critical>
不要重新生成完整文件，使用 replace_in_file 进行定点修改
</critical>

1. 使用 `replace_in_file` 工具更新 brief.mdc 的特定部分
2. 如有新决策，更新 decisions.mdc

<notify>
✅ 已更新记忆库：

- [变更 1：具体说明修改了什么]
- [变更 2：具体说明修改了什么]

更新的文件：`.codebuddy/rules/brief.mdc`
</notify>

### 避免的错误做法

| 错误做法 | 正确做法 |
|----------|----------|
| ❌ 生成 brief.md 然后重命名为 brief.mdc | ✅ 使用 replace_in_file 定点修改 |
| ❌ 重写整个文件 | ✅ 只更新需要变更的部分 |

## 5. 错误处理

| 情况 | 处理方式 |
|------|----------|
| 文件不存在 | 提示用户先执行「初始化记忆」 |
| 更新内容与现有记录冲突 | 询问用户确认，说明冲突点 |
| replace_in_file 失败 | 重新读取文件，检查内容是否已变更 |
| 用户中断更新流程 | 保持原文件不变，告知用户可随时继续 |

## 6. 变更历史格式

更新时保留关键变更的历史：

```markdown
## 当前状态

- **阶段**：成长期
- **焦点**：移动端适配
  > 2025-01-09 更新，原焦点：优化搜索体验
```

或在 decisions.mdc 中记录：

```markdown
### N. 工作焦点调整

**时间**：2025-01-09 14:30

**变更**：工作焦点从「优化搜索体验」调整为「移动端适配」

**原因**：搜索优化已达成目标（响应时间 < 200ms），进入下一阶段
```

## 7. 阶段感知

检测项目阶段变化，不同阶段 AI 的建议风格应该不同：

| 阶段 | 特征 | AI 建议风格 |
|------|------|------------|
| **探索期** | 验证想法、用户调研 | 发散、多提问、鼓励尝试 |
| **MVP** | 最小可用、快速上线 | 聚焦核心、砍需求、快速迭代 |
| **成长期** | 功能完善、体验优化 | 平衡、关注数据、A/B 测试 |
| **成熟期** | 稳定运营、降本增效 | 收敛、风险控制、ROI 导向 |

当检测到阶段变化信号时：

```
AI：项目似乎从 MVP 阶段进入了成长期（开始关注体验优化而非核心功能）。
    要更新记忆库中的项目阶段吗？
```

---

<!-- skill-author: JosephDeng | memory-bank -->
